clear all;close all;fclose all;clc;load('Entry_ypoints.mat');load('Entry_zpoints.mat')
%% DEFINITION OF VARIABLES
um = 0.169;    %mean velocity
Ly = 40e-6;         % domain height
Lz = 150e-6;        % domain width 
ny =400; nz = 1500; % Number of cells
%% CALCULATIONS
a = Lz/2; b = Ly/2; y = -b:Ly/ny:b;z = -a:Lz/nz:a; % Create grid in y direction % Create grid in z direction
alphaa = b/a;    % Aspect ratio of the domain
m = 1.5 + 0.5*alphaa^(-1.4); %  constants
if alphaa <= 1/3
    n = 2;
else
    n = 2 + 0.3*(alphaa - 1/3);
end
for i=1:nz+1
    for j=1:ny+1
        u(i,j) = um * ((m+1)/m) * ((n+1)/n) * (1-(abs(y(j)/b))^n) * (1-(abs(z(i)/a))^m);
    end
end
%% PROCESS STREAMLINES
subplot(1,3,1);contourf(y,z,u); c.LineWidth = 0;colorbar; axis equal;xlim([-20e-6 20e-6]); ylim([-75e-6 75e-6]);hold on; % contourf(y,z,u,5,'ShowText','on')
ax = gca; ax.BoxStyle = 'full'; ax.LineWidth = 2 ; set(gcf, 'Color', 'w'); set(gca,'color','w'); set(gca,'fontsize',10); xlabel( 'Y^* (\mum)', 'fontsize',10); ylabel( 'Z^* (\mum)', 'fontsize',10);box on; grid off;
% ------------------- streamline points from simulation
ypoints = (Entry_ypoints-20)./1000000; zpoints = (Entry_zpoints-75)./1000000; %adjust channel height and width
%  Check the velocity of entry points
subplot(1,3,2);scatter(ypoints,zpoints,'.'); axis equal;xlim([-20e-6 20e-6]); ylim([-75e-6 75e-6]); %check the right place in the channel
ax = gca; ax.BoxStyle = 'full'; ax.LineWidth = 2 ; set(gcf, 'Color', 'w'); set(gca,'color','w'); set(gca,'fontsize',10); xlabel( 'Y^* (\mum)', 'fontsize',10); ylabel( 'Z^* (\mum)', 'fontsize',10); legend('in','Location','southwest'); box on; grid off;
%--------------------- unifrom points in polygon
ypoints = 10000000.*(ypoints); zpoints = 10000000.*(zpoints);
%------approximate polygon
%conv_vertices = convhull(ypoints, zpoints);
%------Exact boundary
conv_vertices = boundary(ypoints, zpoints);
xq = 1:1:400;yq = 1:1:1500;[Xq, Yq] = meshgrid(xq,yq);Xq = Xq(:);Yq = Yq(:);
calculated_area = polyarea(ypoints(conv_vertices), zpoints(conv_vertices));
inside_points = inpolygon(Xq,Yq,ypoints(conv_vertices), zpoints(conv_vertices));
new_y = Xq(inside_points); new_z = Yq(inside_points);

%%--------------------- Get u values
%------- set the number of y and z entry points to the mesh size
new_y=round(new_y,0); new_z=round(new_z,0); new_y= new_y+200;new_z= new_z+750;
subplot(1,3,3);scatter(new_y,new_z,'.');
axis equal; xlim([0 400]); ylim([0 1500]);
ax = gca; ax.BoxStyle = 'full'; ax.LineWidth = 2 ; set(gcf, 'Color', 'w'); set(gca,'color','w'); set(gca,'fontsize',10); xlabel( 'Y^* (\mum)', 'fontsize',10); ylabel( 'Z^* (\mum)', 'fontsize',10); legend('in','Location','southwest'); box on; grid off;
savefig('entry in channel')
%-------(polygon) Get U from the matrix accrording to y and z values
pointend = numel(new_y);uuu = zeros(pointend,1);
for i=1:pointend
    yy = new_y(i); zz = new_z(i); %zz = round(zz,0); yy = round(yy,0);
    uu = u(zz,yy);
    uuu(i)= uu;
end
%-------(streamline points) Get U from the matrix accrording to y and z valuesypoints,zpoints
% pointend = numel(ypoints);uuu = zeros(pointend,1);
% for i=1:pointend
%     yy = ypoints(i); zz = zpoints(i); zz = round(zz,0); yy = round(yy,0);
%     uu = u(zz,yy);
%     uuu(i)= uu;
% end
average_u = sum(uuu)/numel(uuu);
calculated_area;
Q_cavity = 2*average_u*(calculated_area/1000000);
%% normalized flux with channel flux
Q_channel = um*((40*150)/1000000);
%Q_channel = um*Ly*Lz;
Q_norm = Q_cavity/Q_channel;
% Create a table with the data and variable names
T = table(average_u, calculated_area, Q_cavity,Q_channel, Q_norm, 'VariableNames', { 'average_u', 'calculated_area', 'Q_cavity','Q_channel','Q_norm'} )
% Write data to text file
writetable(T, 'Flux_info.txt')
return
%%%%% Get centroid of the region

shp = alphaShape(new_y,new_z)
k = boundary(ypoints,zpoints)
%plot(ypoints(k),zpoints(k));
%[ypoints,xpoints] = centroid(polyarea)
%[xxx,yyy] = centroid(calculated_area)
[x,y] = centroid(conv_vertices)
polyarray = regions(conv_vertices)
polyout = regions(conv_vertices)
conv_vertices = convhull(new_y, new_z);
return

% second build a surface area around points and get velocity vlaues for all
cc = convhull(Entry_ypoints, Entry_zpoints);
xq = 1:0.1:150;yq = 1:0.1:150;[Xq, Yq] = meshgrid(xq,yq);Xq = Xq(:);Yq = Yq(:);cc2 = inpolygon(Xq,Yq,Entry_ypoints(cc), Entry_zpoints(cc));
figure; scatter(Xq(cc2), Yq(cc2)); axis equal;xlim([-2 20]); ylim([0 75]);
%shps = alphaShape(Xq,Yq,10); hold on; shps = plot(shps,'lineStyle','none'); shps.FaceColor = 'k'; alpha 0.7;
Xq=10*Xq;Yq = 10*Yq; Xq = round(Xq,0); Yq = round(Yq,0);
pointend = numel(Yq);uuu = zeros(pointend,1);
%ypoints = 10*Entry_ypoints; ypoints = round(ypoints,0); zpoints = 10*(Entry_zpoints); zpoints = round(zpoints,0);
axis equal
for i=1:pointend
    yy = Xq(i); zz = Yq(i); zz = round(zz,0); yy = round(yy,0);
    uu = u(zz,yy);
    uuu(i)= uu;
end
sum(uuu)
return

%------for 3D flow image
surf(y,z,u) 
shading flat
camlight

% -----------------------After contourf(y,z,u)
% If desired, following part creates a file readable by Tecplot. If not desired,
% just comment out the rest of the code
% fid = fopen('FD_velocities.dat','wt'); fprintf(fid,'TITLE     = "NAME" \n'); fprintf(fid,'VARIABLES = "z" \n'); fprintf(fid,'"y" \n'); fprintf(fid,'"u" \n');fprintf(fid,'ZONE T="Slice: X=0.1" \n');fprintf(fid,'STRANDID=0, SOLUTIONTIME=0 \n');fprintf(fid,'Nodes= %d, Elements= %d, ZONETYPE=FEQuadrilateral  \n',(nz+1)*(ny+1), nz*ny);fprintf(fid,'DATAPACKING=POINT \n');fprintf(fid,'DT=(SINGLE SINGLE SINGLE ) \n');
% for i=1:nz+1
%     for j=1:ny+1
%         fprintf(fid,'%d %d %d \n',z(i),y(j),u(i,j));
%     end
% end
% for i=1:nz
%     counter = (i-1)*(ny+1);
%     for j=1:ny        
%         fprintf(fid,'%d %d %d %d \n',counter+j,counter+j+1,counter+j+1+ny+1,counter+j+ny+1);
%     end
% end
%fclose(fid);

% another code
% clear all; close all;
% h=100e-6;
%  w=100e-6;
%  l=50e-3;
%  v=2.5e-4;
%  z=0;
%  i=0;
%  y=0;
%  while(i<1000)
%  n = 1;
%  ans1=0;
%  ans2=0;
%  term1=0;
%  term2=0;
%  while (n<1000) 
% a=sin(n*pi*z/h);
% b=cosh(n*pi*y/h);
% c=cosh(n*pi*w/(2*h));
% d=(1/(n^3));
% e=tanh(n*pi*w/(2*h));
% f=(192*h)/((n^5)*(pi^5)*w);
% g=(48*v)/(pi^3);
% term1=g*d*(1-b/c)*a;
% term2=f*e;
% ans1=ans1+term1;
% ans2=ans2+term2;
% n=n+2;
% end
% i=i+1;
% result((i+1),1)=ans1/(1-ans2);
% result((i+1),2)=z;
% z=w/999*i;
% end
% xlswrite('Figure6.xlsx',result)
% width = xlsread('Figure6.xlsx', 'B:B')
% avevelocity = xlsread('Figure6.xlsx', 'A:A') 
% plot(width,avevelocity);


%--- test overlap

% Make up some data
x = rand(1,100);
y = rand(1,100);
z = x.^2 + y.^2;
w = x + y;
% Make a contour plot with the w-data.
[xg, yg] = meshgrid(0 : 0.1 : 1);
wg = griddata(x,y,w,xg,yg);
contour(xg,yg,wg);
% Make a scatter3 plot with the z-data, and also use the z-data to color the markers. The fourth input is empty ( [] ) because we want the markers to all be the same size.
hold on
scatter3(x, y, z, [], z);
% Just for good measure
colorbar
return
